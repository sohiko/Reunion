
# Phase 2：方式設計書

## 同窓会サポートWebアプリケーション技術設計書

---

## 1. 技術スタック選定

### 1.1 設計方針と選定基準

本システムの技術スタック選定においては、予算0円という制約の中でセキュリティ要件と運用要件を両立させることが最優先課題となる。同窓会は90年間という長期的運用を前提としており、データの永続性確保と将来的なスケーラビリティも考慮する必要がある。一方で、同窓会という組織の特性上、ユーザー数は比較的限定的であり、大規模なトラフィック処理能力は必ずしも必要としない。

技術選定における評価基準は以下の通りである。第一に無料枠の充実度とし、各サービスの無料プランがどの程度の本システムの要件を満たすかを評価する。第二にセキュリティ対応とし、個人情報保護法（APPI）およびプライバシーを重視する本システムの理念を技術的に支える機能が提供されているかを評価する。第三に運用負荷とし、チームの技術力を考慮し、過度に複雑な設定や管理を必要としないサービスを選定する。第四に拡張性とし、将来的に有料プランへの移行が必要となった場合の移行コストと複雑さを評価する。第五に日本語サポートとし、問題発生時のサポートが日本語で得られることを優先する。

### 1.2 推奨スタック（プランA）：Vercel + Render + Supabase構成

本構成は、フロントエンドからバックエンド、データベースまでを主要な無料枠で賄える現実的な選択肢として推奨する。

フロントエンド層では、Vercelをホスティングプラットフォームとして採用する。VercelはNext.js作者が開発したプラットフォームであり、GitHubリポジトリとの連携による自動デプロイ、全球的なCDNによる高速配信、SSL証明書の自動更新、そしてデフォルトでHTTP/2およびgRPC対応という特性を有する。料金体系として、個人開発者向けHobbyプランでは月額0円で、無制限の帯域幅、100GBのストレージ、および毎秒12,000リクエストまでの処理能力を利用できる。同窓会システムの規模であれば、この無料枠で十分に対応可能である。

フレームワークとしては、React 18以降をコアライブラリとして採用し、UIフレームワークにはChakra UIまたはMantineを採用する。これらのUIフレームワークはアクセシビリティに準拠したコンポーネントを提供し、開発効率と品質の両立が可能である。状態管理にはReact Query（TanStack Query）を採用し、サーバー状態とクライアント状態の管理を分離することで、複雑な状態管理の落とし穴を回避する。

バックエンド層では、RenderをNode.jsアプリケーションのホスティングプラットフォームとして採用する。RenderはPaaS型のサービスであり、サーバー管理の負荷を軽減しながらDockerコンテナベースの実行環境を利用できる。料金体系として、Freeプランでは月額0円で、750時間の実行時間每月、512MBのメモリ、および1GBのストレージを利用できる。ただし、Freeプランでは15分間の非アクティブ状態後コンテナが停止するため、定期的なヘルスチェックによる覚醒が必要となる。

フレームワークとしては、Express.js 5.xをREST APIフレームワークとして採用する。Express.jsはNode.jsを代表する軽量フレームワークであり、ミドルウェアによる柔軟な機能拡張と、既存のエコシステムとの高い親和性が特徴である。ORMとしてはPrismaを採用し、TypeScriptとの高い親和性、型安全なクエリビルダ、および直感的なマイグレーション機能を活用する。

データベース層では、SupabaseをPostgreSQLデータベースとして採用する。SupabaseはFirebaseの代替として開発されたBaaS（Backend as a Service）であり、オープンソースのPostgreSQLを基盤としている。料金体系として、Freeプランでは月額0円で、500MBのデータベース容量、50,000回の月次アクティブユーザー上限、および1GBのファイルストレージを利用できる。PostgreSQLそのものは堅牢なリレーショナルデータベースであり、ACID特性を完全にサポートし、複雑なクエリやトランザクション処理にも対応可能である。

Supabaseの追加機能として、Row Level Security（RLS）を活用したきめ細かなアクセス制御が特筆に値する。RLSを使用することで、SQLレベルでデータアクセスを制御し、アプリケーションレベルのバグによる不正アクセスを防止できる。また、PostgRESTというREST API自動生成機能も備えており、基本的なCRUD操作についてはバックエンドコードを書かずに実装可能である。

オブジェクトストレージ層では、Cloudflare R2を身分証明書画像などの大容量ファイルの保存先として採用する。Cloudflare R2はAWS S3互換のAPIを提供するオブジェクトストレージサービスであり、S3と比較してEgress（下り）転送量無料という大きな特徴がある。料金体系として、Freeプランでは月額0円で、10GBのストレージ保存、100万回の月次読み取りリクエスト、および100万回の月次書き込みリクエストを利用できる。

### 1.3 代替スタック（プランB）：Cloudflare Workers + D1構成

本構成は、サーバーレスアーキテクチャを極限まで追求し、無料枠での常時稼働を実現する選択肢として提案する。

フロントエンドおよびバックエンド層では、Cloudflare Workersをコンピューティング環境として採用する。Cloudflare Workersはエッジコンピューティングプラットフォームであり、世界200以上のPOP（Point of Presence）でコードを実行できる。料金体系として、Freeプランでは月額0円で、1日100,000リクエスト、CPU実行時間10ミリ秒リクエスト、10万回のアップロード、および1GBのKVストレージを利用できる。

フレームワークとしては、HonoをWebフレームワークとして採用する。HonoはCloudflare WorkersやFastly Compute@Edgeなどのエッジ環境に特化した軽量フレームワークであり、高速なルーティングと最小限のオーバーヘッドが特徴である。Cloudflare Workersとの親和性が高く、タイマーcronやDurable Objectsなどのプラットフォーム固有機能もシームレスに利用できる。

データベース層では、Cloudflare D1をSQLiteベースのデータベースとして採用する。D1はCloudflare Workers専用のサーバーレスデータベースであり、SQLite互換のAPIを提供する。料金体系として、Freeプランでは5MBのデータベース容量、1日100,000回の読み取りクエリ、および1日100,000回の書き込みクエリを利用できる。

オブジェクトストレージ層では、プランAと同様にCloudflare R2を採用する。

本構成の強みは、Cloudflareのネットワークを活用した超低レイテンシ配信と、サーバー管理が一切不要な運用負荷の軽さである。一方、複雑なトランザクション処理や長時間のCPU集約型処理には不向きであり、既存のPostgreSQLエコシステム（RLS、トリガー、ストアドプロシージャなど）を活用できないという制約がある。

### 1.4 推奨構成の比較表

| 項目 | プランA（Vercel + Render + Supabase） | プランB（Cloudflare Workers + D1） |
|------|---------------------------------------|-----------------------------------|
| フロントエンド配信 | VercelのグローバルCDN | Cloudflareのグローバルネットワーク |
| バックエンド実行 | Renderコンテナ（常時稼働に近い） | エッジ関数（リクエストごとに実行） |
| データベース | PostgreSQL（Supabase） | SQLite（D1） |
| ストレージ | Cloudflare R2 | Cloudflare R2 |
| 無料枠の制約 | DB 500MB、Render 750時間毎月 | D1 5MB、Workers 10万リクエスト毎日 |
| 複雑なクエリ対応 | ○（PostgreSQLのフル機能） | △（SQLiteの機能制限） |
| トランザクション | ○（ACID完全サポート） | ○（SQLiteのトランザクション） |
| サーバー管理 | 軽度（Renderがコンテナ管理） | ほぼ不要 |
| 技術的成熟度 | ○（広く利用されている技術） | △（比較的新しいサービス） |
| 推奨度 | ★★★★☆（バランス型） | ★★★☆☆（特定ユースケース向け） |

本設計書では、以後の章においてプランA（Vercel + Render + Supabase）を基本構成として説明を進める。プランBを選択する場合も、基本的なアーキテクチャパターンは共通であり、各レイヤーの実装詳細のみが異なる。

---

## 2. 認証・認可設計

### 2.1 認証アーキテクチャ

本システムにおける認証は、パスワードベースの認証と多要素認証の組み合わせを基本としつつ、将来的な外部認証（Google、Microsoftなど）の追加も視野に入れた設計を行う。

認証フローの全体像として、ユーザーがアプリケーションにアクセスすると、まずウェルカムページが表示される。未ログイン状態のユーザーは、ログイン画面または新規登録画面に遷移する。ログイン画面では、メールアドレスとパスワードの入力を受け付け、JWT（JSON Web Token）を発行する。トークンはHTTPOnlyなCookieとしてブラウザに保管し、JavaScriptからの直接アクセスを防止する。トークンの有効期間は短期（1時間）と長期（7日間）の2種類を発行し、短期トークンの更新には長期トークンを使用する。

新規登録フローでは、ユーザーが基本情報を入力後、利用規約とプライバシーポリシーの同意を確認される。同意後、システムは入力されたメールアドレスに確認メールを送信し、リンククリックによりメールアドレスの所有確認を行う。確認完了後、ユーザーはログイン可能となるが、アカウントステータスは「承認待ち」となり、基本機能の利用は制限される。身分証明書のアップロードと役員による承認を経て、初めてすべての機能が利用可能となる。

パスワードポリシーとして、最低12文字以上の長さ、大文字小文字数字記号の混合必須、既知の漏洩パスワードとの照合、および90日ごとのパスワード変更推奨を遵守する。パスワード保存はbcrypt（コストファクター12）を使用し、平文パスワードはメモリ上にも永続化されない設計とする。

多要素認証（MFA）は、役員および幹事に対しては必須とし、一般会員に対してはオプションとして提供する。MFA方式としては、TOTP（Time-based One-Time Password）アルゴリズムに基づく認証アプリ（Google Authenticator、Microsoft Authenticatorなど）との互換性を実装する。バックアップコードも発行し、MFAデバイスの紛失時に備えさせる。

セッション管理として、ログイン状態はJWTで管理するが、サーバーサイドでもトークンのブラックリストを維持し、必要に応じてトークンを無効化できるようにする。ユーザーのパスワード変更、ログアウト、管理者によるアカウント停止時には、関連するすべてのトークンを無効化する。セッション一覧を会員自己在設定ページで確認・撤回可能とし、異常なセッションの検知を可能にする。

### 2.2 認可アーキテクチャ

本システムの認可は、ロールベースアクセス制御（RBAC）を基本としつつ、一部の機能については属性ベースアクセス制御（ABAC）を組み合わせたハイブリッド方式を採用する。

ロール定義として、システムは以下の5種類のロールを設ける。一般会員（GENERAL_MEMBER）は卒業生本人であり、自身の情報管理と他の卒業生との基本的なつながり維持を担当する。幹事（COORDINATOR）は特定学年の運営を担当し、担当学年に関する広範な権限を有する。役員（OFFICER）は全体の統括運営を担当し、全機能にアクセス可能な最上位権限を持つ。教員（TEACHER）は各学年への一斉送信を担当する限定的な権限を持つ。システム管理者（SYSTEM_ADMIN）は技術基盤の維持管理を担当するが、原則として個人情報の閲覧は行わない。

権限マトリクスの実装として、各ロールが持つ権限は、データベースのrolesテーブルにJSONB形式で保存する。APIリクエストの処理時に、認証ミドルウェアがユーザーのロールを取得し、要求された操作に対する権限があるかを確認する。権限チェックは、すべてのデータ操作APIにおいて実装され、ロールによる大まかな制御と、リソース所有権による細かい制御を組み合わせる。

ABACの適用例として、全学年検索の承認フローを挙げる。全学年検索は役員であっても無条件では実行できず、検索理由の入力と他の役員による承認が必要となる。この際、承認者のロール（役員であること）、承認の状態（承認済みであること）、および検索理由の妥当性（属性）を総合的に評価し、検索の実行可否を判断する。

### 2.3 監査ログ設計

本システムでは、すべての重要な操作を監査ログとして記録し、後日の検証と不正検知を可能にする。監査ログは、法的要件（個人情報保護法における安全管理措置）の充足，也是サービスの信頼性を担保する重要な要素である。

記録対象として、すべてのデータ閲覧操作（GETリクエスト）、すべてのデータ変更操作（POST、PUT、PATCH、DELETEリクエスト）、認証関連の操作（ログイン、ログアウト、パスワード変更、MFA設定変更）、および管理者操作（権限変更、設定変更、データエクスポート）を記録する。

ログエントリの構造として、各ログエントリには以下の情報が含まれる。idはUUID形式の主キーであり、timestampはISO 8601形式の操作日時である。user_idは操作を行ったユーザーのIDであり、nullの場合はシステム自動実行を示す。actionは操作の種類であり、VIEW、SEARCH、UPDATE、DELETE、EXPORT、LOGIN、LOGOUT、UPLOAD、DOWNLOAD、APPROVE、REJECT、SEND_MESSAGEなどを取值可能とする。resource_typeは対象となるリソースの種類であり、USER、PROFILE、EVENT、MESSAGE、CONTACT、DOCUMENTなどを取值可能とする。resource_idは対象リソースのIDであり、detailsはJSONB形式で操作の詳細情報を保存する。ip_addressはIPv4またはIPv6形式のクライアントIPアドレスであり、user_agentはクライアントのUser-Agent文字列である。requires_approvalは承認が必要な操作かどうかのフラグであり、approval_statusは承認状態を示す。approved_byは承認者のIDであり、approved_atは承認日時である。

ログの保護として、監査ログは通常のデータとは別のテーブルに存储し、管理者であっても削除・更新を禁止する設計とする。具体的には、監査ログテーブルに対するUPDATEおよびDELETE権限をアプリケーションレベルで完全に禁止し、INSERT権限のみを許可する。データベースレベルでは、トリガーを用いてログエントリの作成後の変更を不可能にする。ログの长期保存として、監査ログは90年間のデータ保持期間中は保存し、古いログは归档テーブルに移行して 查询性能を維持する。

ログの閲覧権限として、幹事は担当学年に関するログのみ閲覧可能とし、役員は全ログを閲覧可能とする。システム管理者はログ閲覧権限を持たない。ログ閲覧自体も監査ログに記録され、誰がいつログを閲覧したかが追跡される。

### 2.4 APIセキュリティ

APIのセキュリティは、認証・認可と連携して、システム全体の安全性を確保する上で極めて重要である。

認証トークンの管理として、JWTはHTTPOnlyなCookieでクライアントに передачし、XSS（クロスサイトスクリプティング）によるトークン漏洩を防止する。SameSite属性をStrictまたはLaxに設定し、CSRF（クロスサイトリクエストフォージェリ）攻撃への対策を講じる。トークンの有効期間は短めに設定し、更新トークンの使用を必須とする。

入力検証として、すべてのユーザー入力に対してサーバサイドで厳格なバリデーションを実施する。DTO（Data Transfer Object）パターンを採用し、APIリクエストのスキーマを明確に定義して、不正なデータがアプリケーションロジックに到達する前に排除する。SQLインジェクション対策として、PrismaORMのパラメータ化クエリを必ず使用し、生SQLの実行は最小限に抑える。XSS対策として、HTMLエンティティのエスケープを徹底し、Content-Typeの正しい設定によりJSON以外の responseを防止する。

レート制限として、APIリクエストに対するレート制限を実装し、DoS（Denial of Service）攻撃やブルートフォース攻撃への対策を講じる。レート制限はIPアドレス単位およびユーザー単位で適用し、認証済みユーザーと未認証ユーザーで異なる制限値を設ける。レート制限を超過したリクエストには、429 Too Many Requestsエラーを返却し、Retry-Afterヘッダで次回可能時刻を伝える。

CORS（Cross-Origin Resource Sharing）として、本番環境では信頼できる発信元からのリクエストのみを許可する。開発環境では検証用の発信元を許可するが、本番環境では厳格なホワイトリスト方式を採用する。Credential（Cookieなど）の передачが認められる発信元は、信頼できる発信元のみに限定する。

---

## 3. 暗号化設計

### 3.1 暗号化の基本方針

本システムで扱う情報は、同窓会の卒業生という特定個人の連絡先情報を中心に、個人情報保護法（APPI）で定義される「要配慮個人情報」を含む可能性がある。身分証明書画像更是高度の機密情報であり、これらの情報保护はシステム设计の最重要事項である。

暗号化の対象として、個人情報ではない公開情報（氏名、卒業年、学生番号など）はハッシュ化せず平文で保存し、検索性や並べ替えを可能にする。機微情報（メールアドレス、電話番号、現住所など）は暗号化して保存し、閲覧時に復号化する。身分証明書画像はオブジェクトストレージに 保存하되、ファイルそのものは暗号化して保存する。高機密情報（身分証明書、生年月日など、特に定めのない機密情報）はさらに厳格なアクセス制御のもとで扱う。

暗号化アルゴリズムとして、対称鍵暗号化にはAES-256-GCMを採用する。GCMモードは認証付き暗号であり、暗号文の完全性と真正性を同時に保证する。非対称鍵暗号化にはRSA-2048以上またはCurve25519を採用するが、対称鍵暗号化の補助的な用途（鍵の暗号化など）に限定する。パスワード 保存にはbcryptを、コストファクター12で使用する。

### 3.2 保存時の暗号化（Encryption at Rest）

データベース内の暗号化として、機微情報カラムはアプリケーションレベルで暗号化して保存する。これにより、データベース管理者やデータベースへの不正アクセスが発生した場合でも、暗号化された情報は解密键なしには解读不能となる。

暗号化の実装として、機微情報を保存するカラムは、すべてTEXT型として暗号化されたBase64エンコード字符串を 保存する。暗号化関数では、平文テキストにソルト（16字节の随机値）を付加し、AES-256-GCMで暗号化します。暗号化结果は、暗号文（12字节のIV + 暗号文 + 16字节の認証タグ）をBase64エンコードして保存します。復号化時には、Base64デコード後、IVと認証タグを分离し、AES-256-GCMで復号化します。

身分証明書画像の暗号化として、身分証明書画像は、オブジェクトストレージ上传达する前に暗号化を施す。暗号化にはAES-256-GCMを使用し、ファイル内容を256字节のブロックに分割して個別に暗号化する。ファイル名には元のファイル名を保存せず、UUID形式のランダム名を割り当て、ファイル拡張子のみを保持する。暗号化键は、他の機微情報の暗号化键とは 별도의键を使用し、 rotation も可能とする設計とする。

键管理として、すべての暗号化键は環境変数で管理し、ソースコードや设定ファイルに平文で 保存しない。production 环境では、AWS Secrets Manager、Google Cloud Secret Manager、またはHashiCorp Vaultなどの专门的键管理サービスの免费枠を活用する。development 环境では、環境変数ファイル（.env.local）から键を 읽어 들이며、.env.example にはダミー値を记载して、セットアップ手順を 明示する。

### 3.3 通信時の暗号化（Encryption in Transit）

すべての通信経路でTLS（Transport Layer Security）を必須とし、通信内容の盗聴や改ざんを防止する。

TLS設定として、サーバー侧ではTLS 1.2以上を必须とし、TLS 1.3の使用を推奨する。証明書はLet’s Encryptから бесплатноに取得し、Auto Renewalを設定する。証明書到期の30日前からアラートを発信し、到期によるサービス停止を防止する。Cipher Suitesは、AES-256-GCM系列の強力な暗号スイートのみを许可し、脆弱な暗号スイートは无效化する。

HTTP Strict Transport Security（HSTS）として、HTTPリクエストをHTTPSに强制リダイレクトする設定を実施する。HSTSヘッダを出力し、ブラウザ下次以降のアクセスでもHTTPSを强制する。Preload Listへの登録を検討し、ブラウザレベルでHTTPSを强制する。

Certificate Transparency（CT）として、証明書の発行记录を公开日志に记录し、不正な証明書の発見を容易にする。CT logへの参加を поддерживать する証明書を取得する。

### 3.4 バックアップの暗号化

データベースバックアップとオブジェクトストレージのバックアップは、暗号化を施して저장한다。

バックアップ暗号化として、pg_dumpによるデータベースバックアップは、AES-256-GCMで暗号化した上で上传达する。暗号化键は、本番環境の暗号化键とは 别個のバックアップ専用の键を使用し、本番键の漏洩がバックアップ漏洩に直結するのを防止する。バックアップファイルの完整性验证のため、SHA-256ハッシュを计算し、別の場所に保存する。

バックアップ键の管理として、バックアップ键は、本番環境の键管理システムとは 別の场所に保存する。备份键へのアクセスは、极少数の信頼できる担当者のみに限定する。键のrotationを定期的に実施し、长期间同じ键を使用し続けるリスクを低減する。

---

## 4. 身分証明書アップロードの安全設計

### 4.1 アップロードプロセスの設計

身分証明書は、本人确认のための最も重要な证据であり、その取り扱いは最高レベルのセキュリティを要求する。

アップロードフローとして、ユーザーは自己のプロファイルページから「身分証明書アップロード」画面に遷移する。システムは、身分証明書の规格（ファイル形式：JPEG/PNG、最大サイズ：5MBなど）を表示し、アップロードを促す。ユーザーがファイルを選択すると、まずクライアント侧でファイル形式とサイズのバリデーションを実施する。その後、ファイルを серверにアップロードし、サーバ侧で再度バリデーション（Magic Numberによるファイル形式确认、MIME Type检查など）を実施する。服务器は、アップロードされたファイルを暗号化し、オブジェクトストレージに保存する。保存後、用户にはアップロード完了画面が表示され、身分証明書のステータスは「審査待ち」に更新される。

アップロード時のバリデーションとして、ファイル形式はJPEG、PNG、およびPDFに限定し、他の形式は拒否する。ファイルサイズは5MB以下に制限し、それ以上のファイルは拒否する。画像ファイルの場合、画像の内容（ Magic Number）を检查し、拡張子を偽装した攻击を防止する。 Virus Scan（ClamAVなど）を导入し、マルウェアの upload を检测する。

ファイル名の处理として、元のファイル名は破棄し、UUID形式のランダム名を割り当てて保存する。ファイル拡張子は、检测された实际のファイル形式に基づいて设定する（例： detectar PNG → .png）。用户がファイル名から身份情報を推測することはできない。

### 4.2 ストレージの安全設計

身分証明書画像は、专门のオブジェクトストレージバケットに 保存し、通常の画像などとは 分离して管理する。

バケット设定として、身分証明書用バケットは「プライベート」设定とし、直接URLでのアクセスを禁止する。バケットポリシーにより、バックエンドサーバーからのみ read/write を许可する。バケットのACL（Access Control List）を严密に設定し、不要なアクセス権限を付与しない。

アクセス制御として、身分証明書を閲覧する際には、バックエンドが署名付きURL（Presigned URL）を発行する。署名付きURLの有効期間は5分以内に设定し、短期間で無効化する。署名付きURLの発行 时、アクセス元IPアドレスの记录を行い、异常なアクセスを检测する。身分証閲覧権限は役員のみに许可し、幹事や一般用户は閲覧できない。

ログ记录として、身分証明書へのアクセス（閲覧、ダウンロード）はすべて审计ログに记录する。ログには、アクセス者（用户ID）、アクセス对象（用户ID）、アクセス时间、アクセス元IPアドレス、およびアクセス目的を含める。

### 4.3 保持期間と削除方針

身分証明書は、本人确认作业完了後は速やかに削除し、长期间保存によるリスクを低減する。

保持期间として、本人确认作业中（承認待ち）の身分証明書は、最长90日間保持する。承認完了後、身分証明書は30日以内に削除するか、完全に匿名化する。ただし、违法行为の調査など正当な理由がある場合は、法令上の保存期间に従う。

削除プロセスとして、削除は物理削除（ファイルそのものを storage から remove）を原则とする。削除前に対象ユーザーに削除予定日を通知し、異論があれば対応する。削除作业は、監査ログに完全に記録し、誰がいつ削除したかを明确にする。削除後、ユーザーには削除完了通知を送信する。

紧急时的削除として、ユーザーからの削除请求があった场合、速やかに身分証明書を削除する。システム管理者または役員が、不正な身分证 Usage を発見した场 合、一時的にアクセスを停止し、调查後删除する。

### 4.4 アクセス制限の実装

身分証明書へのアクセスは、技术的措置と管理的措置の両面から严格に制御する。

技术的措置として、バケットポリシーにより、直接アクセスを禁止する。签名付きURLの有効期間を5分に设定し、短期間で失效させる。アクセスログを实时で监控し、异常なアクセスパターンを检测する。IPアドレスのホワイトリストを设定し、信頼できるIPアドレスからのアクセスのみを许可する。

管理的措置として、身分证閲覧権限は役員に限定し、幹事や一般用户には許可しない。閲覧前に、身分证閲覧の目的と责任を记载した誓約書への同意を求める。閲覧作业は他の役員に通知され、単独での作业を回避する。閲覧後、一定期间内に作业を完了し、签名付きURLの再発行を必要とする。

---

## 5. メール・SMS送信設計

### 5.1 メール送信の設計

本システムでは、イベント告知、一斉連絡、個別の通知など、各種邮件の发送を行う。免费枠での运用を前提としつつ、確実に邮件を送达できる 设计を採用する。

メールサービス选定として、SendGridを主たる邮件サービスとして选定する。SendGridはTwilio社が提供する邮件配信サービスであり、免费枠（Hobbyプラン）では1日100通まで、每月10,000通までの发送が可能である。SendGridのAPIを使用して邮件を发送し、配信状况（开封率、バウンス率、投诉率など）をモニタリングする。

代替サービスとして、Mailgunを代替サービスとして设定する。Mailgunは邮件配信サービスであり、免费枠では每月5,000通までの发送が可能である。SendGridで障害が発生した場合、またはSendGridの免费枠の上限に達した場合は、Mailgunに切换える。切换は设定ファイルの変更のみで可能とし、サービス停止時間を最小限に抑える。

fallback机制として、SendGridとMailgunの両方が利用不能な极端な状况に備え、SMTPリレーを通过した发送も可能とする。GmailのSMTP服务器（免费枠で1日500通まで）を最终手段として设定する。ただし、GmailのSMTPは发送元がGmailアドレスに限定されるため、通知先地址が限定される。

邮件テンプレートとして、イベント告知、联系人開示の承認请求、システムの通知など、种类ごとにメールテンプレートを准备する。テンプレートはHTML形式とし、ブランドアイデンティティを反映したデザインを採用する。模板内の変数（用户名、イベント名など）は置換可能とし、パーソナライズされた邮件を发送する。

配信管理として、大量の邮件を发送する際は、速率制限（Rate Limiting）を遵守し、短时间に大量の邮件を发送しない。邮件のクリック率和开封率をモニタリングし、用户のエンゲージメントを测定する。投诉（ spam 举报）が発生した場合は、地址をブラックリストに登録し、以後の发送を停止する。

### 5.2 SMS送信の設計

SMSは、紧急の連絡やメールを確認しない可能性のある用户への連絡手段として位置付ける。免费枠での运用には重大な制约があるため、段階的な导入を計画する。

SMSサービスの现状として、Twilio、AWS SNS、Nexmoなどの主要SMSサービスは、免费枠の提供が极其限定的である。Twilioは初回开户時に15ドルのクレジットを提供するが、以降の利用は有料である。AWS SNSは無料枠外でSMSを送信し、日本への发送は1件あたり数円〜十数円の费用が発生する。予算0円の制約下では、SMSの发送は限定的な利用に留めざるを得ない。

段階的导入計画として、MVP（Minimum Viable Product）段階ではSMSは実装せず、アプリ内通知とメールのみを実装する。用户からの要望や运用上の必要性に応じて、段階的にSMS機能を导入する。SMS导入时は、发送对象を役員・幹事に限定し、一般用户への发送は有料化する场合のみ许可する。发送费用を事前に设定した预算内で管理し、予算を超えた发送は自動的に抑制する。

替代手段として、SMSの发送が困难な状况に備え、以下の替代手段を提供する。アプリ内通知として、アプリにログインした用户にはアプリ内で通知を行い、PUSH通知（対応机器の場合）も发送する。Line Notifyとして、Lineの公式アカウントから通知を发送し、Line用户에게는効率的にリーチできる。电话联系として、极其紧急の状况では、电话による直接連絡を最终手段として准备する。

### 5.3 通知の設計

通知は、用户に対して重要な情報を传达するための机制であり、複数のチャネルを通じて確実にリーチすることを目的とする。

通知カテゴリとして、认证通知（登录确认、パスワードレスト、MFAコードなど）、システム通知（アカウント状态变更、隐私设定变更など）、メンバー通知（联系人開示の申请结果、同级生からのメッセージなど）、イベント通知（イベント告知、出欠リマインダー、イベント更新など）、および管理通知（削除请求への対応依頼、审计日志の异常検知など）を分类する。

通知チャネルとして、用户が受信を好むチャネルと、通知の重要度に応じた适材适所のチャネル选择を行う。重要な通知（认证通知、アカウント状态变更など）は、メール、SMS、アプリ内通知のすべてで发送する。一般の通知（イベント告知など）は、メールおよびアプリ内通知で发送する。低优先度の通知（活动更新など）は、アプリ内通知のみで发送する。

通知设定として、用户は notification 設定页面から、各カテゴリの通知を哪个チャネルで受信するかを设定できる。通知の频度制限（例：1时间に1回までのまとめ发送）も设定可能とし、通知疲れを防止する。

---

## 6. バックアップ・復元設計

### 6.1 バックアップ戦略

90年間のデータ保持を前提としつつ、システムの障害や人為的误操作に備え、包括的なバックアップ戦略を策定する。

バックアップ类型として、完全バックアップ（Full Backup）は、データベース全体のバックアップを每周1回、实施する。完全バックアップは恢复の基准点として機能し、バックアップ恢复の最终手段となる。差分バックアップ（Differential Backup）は、前回の完全バックアップ以降の变更を每日备份する。差分バックアップは、恢复时间を短縮しつつ、ストレージ使用量を抑制する。增量バックアップ（Incremental Backup）は、前回の任意のバックアップ以降の变更を实时で备份する。增量バックアップは、最小のストレージ使用量で最大の恢复 point を提供する。

バックアップ对象として、データベース（PostgreSQL）の完全バックアップを每日期施する。オブジェクトストレージ（身分証明書画像など）の完全バックアップを每周施する。アプリケーション设定ファイル（环境変数、设定ファイルなど）のバージョン管理をGitで実施する。SSL証明書の自动续订と連携したバックアップを取得する。

バックアップ先として、プライマリバックアップ先は、Supabaseのビルトインフラ（每日自动バックアップ）を活用する。セカンダリバックアップ先は、Cloudflare R2に手动でアップロードする。地理的に離れた场所にバックアップを复制するため、異なるリージョンにバックアップを配置する。

### 6.2 バックアップの暗号化と整合性検証

バックアップデータは、机密情報を含む可能性があるため、暗号化を施して保存する。

バックアップ暗号化として、pg_dumpによるデータベースバックアップは、AES-256-GCMで暗号化してR2に上传达する。暗号化键は、本番环境の暗号化键とは 别個のバックアップ専用の键を使用する。暗号化したバックアップファイルの完整性を検証するため、SHA-256ハッシュを计算して 别々保存する。

整合性検証として、每日バックアップの作成後、 restoration test を実施する。テスト环境にバックアップを復元し、データの完全性を确认する。ハッシュ値を对照し、バックアップファイルが改ざんされていないことを確認する。バックアップの整合性検証结果を日志に记录し、异常が发见された場合はアラートを発信する。

### 6.3 復元手順

障害発生時に備え、明确な復元手順を文書化し、定期的に演练を実施する。

復元步骤として、第一ステップでは障害の影響範囲を評価し、恢复が必要なデータを特定する。第二ステップでは最新の正常なバックアップを特定し、复原計画を策定する。第三ステップではデータベースをバックアップから復元する。R2から暗号化されたバックアップファイルをダウンロードし、復号化する。Prismaの migrate コマンドを実行し、スキーマを最新の状态に更新する。第四ステップではオブジェクトストレージ（身分証明書など）を復元する。第五ステップではアプリケーションを再起動し、サービスが正常に启动することを確認する。第六ステップでは用户に対して服务恢复を通知し、影响範囲と復旧状況を报告する。

復元時間目標（RTO）として、データベースの完全復元に4時間以内、アプリケーションの完全稼働に1時間以内を目標とする。重要なデータが失われないよう、差分バックアップを每日取得し、最大1日分のデータ损失に抑える。

復元演练として、四半期ごとに復元演练を実施し、手顺の有効性を确认する。演练结果を文档化し、改善点を洗い出して対処する。演练で発见された问题点を踏まえ、手顺書を定期的に更新する。

### 6.4 自動削除jobsの設計

データ保持期間（90年）に达したデータを自动削除するjobsを设计する。

削除対象として、会員データ（users、profilesテーブル）は、退会処理完了から90年後に削除する。監査ログ（audit_logsテーブル）は、作成から90年後に归档テーブルに移行し、さらに10年後に削除する。身分証明書（verification_documents）は、承認完了または否認から30日後に削除する。一時データ（セッショントークン、パスワードリセットトークンなど）は、有効期限切れ後に削除する。

jobの设计として、削除jobsは每日凌晨2时（JST）に执行するCron jobとして実装する。削除対象は、created_atまたはdeleted_atのタイムスタンプに基づいて SELECTする。削除前に対象件数を確認し、大量のデータが削除される場合は分期的に削除する（例：1回あたり1000件）。削除処理はトランザクション内で実行し、エラーが発生した場合はロールバックする。

削除前の确认として、本人にデータエクスポートの機会を提供するため、削除の30日前に用户に通知する。通知には、削除予定日、导出可能なデータ种类、および导出申请方法を记载する。用户から导出请求があった场合、削除を延期し、导出を完了後再度削除スケジュールを設定する。

### 6.5 バックアップ運用手順

日常的なバックアップ運用と、定期的な検証作业手順を定める。

日常運用として、每日凌晨0时（JST）に完全バックアップを取得する。バックアップ作成後、ログに记录し、异常があった場合はアラートを発信する。バックアップファイルをR2に上传达し、アップロード完了を確認する。每周1回、 backups の整合性検証を実施する。

週次作业として、每周月曜日に完全バックアップからの復元テストを実施する。復元したデータに対し、基本的なクエリが実行できることを確認する。復元作业の所要時間を测定し、RTOの目标を达成できているか确认する。

年次作业として、每年末に年間のバックアップ日志を汇总し、问题点の洗い出しと改善計画を策定する。 backups の保持期間と削除ポリシーの見直しを実施する。復元演练を実地し、作业手順書の更新が必要かを判定する。

---

## 7. 環境構成

### 7.1 環境分離

本システムでは、development、staging、productionの3つの環境を設け、それぞれ独立した设定とリソースで運用する。

development環境として、ローカル開発環境であり、開発者が各自的開発を行う環境である。データベースはDocker ComposeでPostgreSQLをローカルに起動する。オブジェクトストレージはLocalStackまたはMinIOをローカルに起動する。データは開発用にダミーデータで初期化する。设定値は.env.localファイルから読み込み、本番環境とは異なる値を使用する。

staging環境として、本番環境へのデプロイ前の検証環境である。RenderとSupabaseに専用のインスタンスを构筑する。本番環境と同等の设定値を使用するが、クリティカルなシークレットは别個の値を使用する。テストユーザーとテストデータで検証を行う。

production環境として、本番サービス提供環境である。RenderとSupabaseの本番インスタンスを构筑する。すべての设定値が本稼働用の値を使用する。SSL証明書はLet’s Encryptで自动取得・更新する。モニタリングとアラートを全线に設定する。

### 7.2 CI/CDパイプライン

継続的インテグレーション・継続的デプロイ（CI/CD）パイプラインを構築し、品质の高いソフトウェアを効率的にリリースする。

パイプラインの構成として、GitHub Actionsを使用してCI/CDパイプラインを構築する。mainブランチへのpush時に自動的にパイプラインが执行される。staging環境へのデプロイはmainブランチへのpush時に自动実行される。production環境へのデプロイは、release tagの作成時に手动确认フローを経て実行される。

CI/CDの步骤として、第一ステップでは代码の lintingと格式化（ESLint、Prettier）を実施する。第二ステップでは TypeScriptの 型检查を実施する。第三ステップでは 单元テスト（Vitest、Jest）を実行する。第四ステップでは 結合テスト（Playwright）を実行する。第五ステップでは Docker imageの buildと pushを実施する。第六ステップでは Renderへのデプロイを実行する。第七ステップでは デプロイ後のヘルスチェックを実行する。

テスト戦略として、单元テストはコアロジック（暗号化、認証、認可など）を重点的にカバーする。結合テストは主要ユーザーアクション（ログイン、登録、プロフィール更新など）をカバーする。E2Eテストはクリティカルなユーザーフロー（登録から承認、イベント作成から出欠など）をカバーする。テストカバレッジ目標は80%以上とする。

### 7.3 環境変数管理

環境変数は、アプリケーションの设定を管理する重要な要素であり、セキュリティと运用の観点から慎重に管理する。

環境変数の種類として、データベース接続情報（DATABASE_URL、DB_HOST、DB_PORT、DB_USER、DB_PASSWORDなど）、認証シークレット（JWT_SECRET_KEY、REFRESH_TOKEN_SECRETなど）、暗号化键（ENCRYPTION_KEY、ENCRYPTION_IVなど）、メールサービス设定（SENDGRID_API_KEY、MAILGUN_API_KEYなど）、およびその他の设定（APP_URL、NODE_ENV、LOG_LEVELなど）を含む。

環境変数の管理として、本番環境の環境変数はRenderのシークレット管理機能を使用して设定する。環境変数の値は、ソースコードやgitリポジトリに平文で含めない。development環境の環境変数は、.env.localファイルから読み込み、.env.exampleにはダミー値を记载する。環境変数の rotation（键の更换）を定期的に実施し、長期間同じ値を使用し続けるリスクを低減する。

---

## 8. 運用設計

### 8.1 監視とアラート

システムの健全性を継続的に監視し、問題の早期検知と迅速な対応を可能にする。

監視項目として、アプリケーションのレスポンスタイムと错误率を監視する。データベースの接続数、クエリ実行時間、磁盘使用量を監視する。オブジェクトストレージの使用量とAPIリクエスト数を監視する。サーバー（Renderコンテナ）のCPU使用率、メモリ使用量、ネットワーク流量を監視する。バックアップの取得状况と整合性検証結果を監視する。

アラートの设定として、重大な问题（サービス停止、データベース接続失败など）は即座にアラートを発信し、担当者に电话連絡を行う。中程度の問題（レスポンスタイムの延迟、错误率の上升など）はSlackなどのチャットツールに通知し、业务时间内に对应する。軽微な问题（リソース使用量の上限接近など）はログに记录し、定期的なレビューで对应する。

ログ管理として、アプリケーションログは構造化されたJSON形式で出力し、検索・分析を容易にする。ログはレベル（ERROR、WARN、INFO、DEBUG）を设定し、本番环境ではDEBUGレベルを抑制する。ログは一定期间（30日間）保持し、それ以前のアーカイブはR2に保存する。ログの分析には、Renderのログストリーミングと、オプションとしてDatadogやCloudflare Logsなどのサービスを活用する。

### 8.2 インシデント対応

問題発生時の対応手順を明確化し、迅速かつ適切な対応を可能にする。

インシデントの分類として、レベル1（重大）はサービス完全停止または大規模なデータ损失であり、即座に対応する。レベル2（高）はサービス一部停止またはセキュリティ侵害の疑いであり、1時間以内に対応する。レベル3（中）は機能の一部障害または性能劣化であり、24時間以内にに対応する。レベル4（低）は軽微な问题または不便であり、顺次にに対応する。

対応手順として、第一ステップでは问题の検知と影响範囲の評価を行う。第二ステップではインシデント対応の责任者を决定し、対応の指挥を執らせる。第三ステップでは原因の特定と暫定对策の実施を行う。第四ステップでは恒久对策の策定と实施を行う。第五ステップでは事後レビューを実施し、再発防止策を策定する。

コミュニケーションとして、インシデント発生時は用户に対して速やかに状況を通报する。定期的な更新情報を提供し、対応の進捗状況を传达する。解决後には、発生原因と対応状況を报告する。

### 8.3 運用手順書

日常の運用作业と、定期的な maintenance 作业を文书化し、担当者が迷うことなく作业を実行できるようにする。

日常作业として、每日凌晨にバックアップの取得状况を確認する。每朝始业時にシステムの健全性を确认する。アラートが発生した場合は速やかに调查・対応する。

週次作业として、週1回はバックアップからの復元テストを実施する。セキュリティログを确认し、异常なアクセスを检测する。 SSL証明書の有効期限を確認する。

月次作业として、リソース使用量の趋势を分析し、キャパシティプランニングに反映する。 aplicaciónのログを分析し、パフォーマンス问题や异常を检测する。环境変数のローテーションを実施する。

四半期作业として、完全な复原演练を実施する。セキュリティ診断（脆弱性スキャン）を実施する。运用手顺書のレビューと更新を実施する。

---

## 9. 次のステップ

本ドキュメント（Phase 2：方式設計）では、同窓会サポートWebアプリケーションの技術的な方式設計を完了した。次回のPhase 3では、この方式設計に基づいて実際の実装を進める。

Phase 3で扱う主要なトピックは以下の通りである。リポジトリ構成として、Monorepo（単一リポジトリ）またはPolyrepo（複数リポジトリ）の选定と、ディレクトリ构造の設計を行う。DBマイグレーションとして、Prismaを使用したマイグレーションファイルの作成と、初回マイグレーションの実行を行う。API/画面の実装として、RESTful APIのエンドポイント設計と実装、およびReactによる画面の実装を行う。ログ・監査ログの実装として、監査ログの取得と保存、処理の実装を行う。権限制御の自动テストとして、各ロールの権限が正しく機能することを検証する自動テストの作成を行う。

---

以上